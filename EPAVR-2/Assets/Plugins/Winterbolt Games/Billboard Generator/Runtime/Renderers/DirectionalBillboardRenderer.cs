using System.Collections.Generic;
using UnityEngine;

namespace WinterboltGames.BillboardGenerator.Runtime.Renderers
{
	/// <summary>
	/// Renders a material with a texture generated by Billboard Renderer as a directional billboard.
	/// </summary>
	public sealed class DirectionalBillboardRenderer : BillboardRendererBase
	{
		[SerializeField]
		[Tooltip("The atlas used by the billboard renderer.")]
		private BillboardAtlasAsset atlas;

		[SerializeField]
		[Tooltip("Starting from version 6.0.0 when using the alternative workflow mode use the following to scale the billboard instead of transform.localScale.")]
		private Vector3 localScale = Vector3.one;

		/// <summary>
		/// The last recorded value of _localScale.
		/// </summary>
		private Vector3 _lastLocalScale = new Vector3(float.NaN, float.NaN, float.NaN);

		/// <summary>
		/// The angle that the billboard will try to snap to angles divisible by it.
		/// If it is for example 45 then the billboard will snap to 0, 45, 90, 135, 180, 225, 270, 315, 360.
		/// </summary>
		private int _snap;

		/// <summary>
		/// A dictionary where the key is an angle and the value is the index of the 
		/// UV coordinates that represents the position of the billboard texture that
		/// represents that angle in the billboard atlas texture.
		/// </summary>
		private readonly Dictionary<int, int> _directions = new Dictionary<int, int>();

		public override bool IsValid(bool warn = true)
		{
			if (useAlternativeWorkflow)
			{
				if (meshFilter == null)
				{
					if (warn) Debug.LogWarning($"{name} has no {nameof(meshFilter)} assigned.", this);

					return false;
				}

				if (meshRenderer == null)
				{
					if (warn) Debug.LogWarning($"{name} has no {nameof(meshRenderer)} assigned.", this);

					return false;
				}
				else if (meshRenderer.sharedMaterials.Length < 1)
				{
					if (warn) Debug.LogWarning($"{name} has a {nameof(meshRenderer)} assigned but with no materials.", this);

					return false;
				}
			}
			else
			{
				if (material == null)
				{
					if (warn) Debug.LogWarning($"{name} has no {nameof(material)} assigned.", this);

					return false;
				}
			}

			if (atlas == null)
			{
				if (warn) Debug.LogWarning($"{name} has no {nameof(atlas)} assigned.", this);

				return false;
			}

			return true;
		}

		public override void PrepareBillboard()
		{
			base.PrepareBillboard();

			_snap = 360 / atlas.uvCoordinates.Count;

			for (int i = 0; i < 360 / _snap; i++)
			{
				_directions.Add(i * _snap, i);
			}
		}

		public override void UpdateBillboard()
		{
			if (target == null || useAlternativeWorkflow && !meshRenderer.isVisible) return;

			Vector3 targetPosition = target.position;

			if (lastTargetPosition == targetPosition && _lastLocalScale == localScale && !transform.hasChanged) return;

			lastTargetPosition = targetPosition;

			_lastLocalScale = localScale;

			Vector3 cachedPosition = cachedTransform.position;

			Vector3 direction = cachedPosition - targetPosition;

			float rawAngle = Mathf.Atan2(direction.x, direction.z) * Mathf.Rad2Deg;

			float parentAngle = (cachedTransform.parent == null ? 0.0f : cachedTransform.parent.eulerAngles.y) % 360.0f;

			parentAngle = parentAngle < 0.0f ? parentAngle + 360.0f : parentAngle;

			int angle = Mathf.CeilToInt(rawAngle - parentAngle) / _snap * _snap % 360;

			if (angle < 0) angle += 360;

			if (_directions.TryGetValue(angle != 0 && angle != 360 ? angle : 0, out int index))
			{
				UVCoordinates uvs = atlas.uvCoordinates[index];

				this.uvs[0] = uvs.bottomLeft;
				this.uvs[1] = uvs.bottomRight;
				this.uvs[2] = uvs.topRight;
				this.uvs[3] = uvs.topLeft;
			}

			mesh.uv = uvs;

			cachedTransform.rotation = Quaternion.Euler(0.0f, rawAngle, 0.0f);

			if (useAlternativeWorkflow) cachedTransform.localScale = GetScale(false);

			if (cachedTransform.hasChanged) cachedTransform.hasChanged = false;
		}

		public override void RenderBillboard()
		{
			Graphics.DrawMesh(mesh, Matrix4x4.TRS(cachedTransform.position, cachedTransform.rotation, GetScale()), material, gameObject.layer);
		}

		/// <summary>
		/// Calculates the scale of the billboard taking into account the scale of the current UV coordinates.
		/// </summary>
		/// <param name="lossy">Whether to scale the result by the <see cref="Transform.localScale"/> or not.</param>
		/// <returns>The scale of the billboard taking into account the scale of the current UV coordinates.</returns>
		private Vector3 GetScale(bool lossy = true)
		{
			return lossy ? Vector3.Scale(atlas.rendererScale, cachedTransform.lossyScale) : Vector3.Scale(atlas.rendererScale, localScale);
		}
	}
}
